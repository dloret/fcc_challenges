<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Technical documentation page</title>
  <link rel="stylesheet" href="style/style.css">
</head>

<body>
  <nav id="navbar">
    <header>Asynchronous JavaScript</header>
    <ul>
      <a href="#Introduction" class="nav-link" rel="internal">
        <li>Introduction</li>
      </a>
      <a href="#Prerequisites" class="nav-link" rel="internal">
        <li>Prerequisites</li>
      </a>
      <a href="#Introducing_async_JavaScript" class="nav-link" rel="internal">
        <li>Introducing async JavaScript</li>
      </a>
      <a href="#Async_loops_and_intervals" class="nav-link" rel="internal">
        <li>Async loops and intervals</li>
      </a>
      <a href="#Async_operations_with_Promises" class="nav-link" rel="internal">
        <li>Async operations with Promises</li>
      </a>
      <a href="#Easier_async_programming_with_async_await" class="nav-link" rel="internal">
        <li>Easier async programming with async await</li>
      </a>
    </ul>
  </nav>

  <main id="main-doc">
    <section class="main-section" id="Introduction">
      <header>Introduction</header>
      <article>
        <p>Asynchronous JavaScript is used to effectively handle potential blocking operations such as fetching
          resources from a server. When only one thing happens at once, a function depending on another function has to
          wait for the other function to finish and return. From the perspective of the user, the program is essentially
          stopped during that time and a spinning cursor on the screen is generally visible.</p>
        <p>This is a frustrating experience and a waste of computing processing power.Asynchronous programming lets you
          get other work done in the meantime. This is important in the case of web browsers. When a web app runs in a
          browser and it executes and intensive chunk of code without returning control to the browser, this one can
          appear to be frozen. This is called <strong>blocking</strong>: the browser is prevented from handling user
          input.</p>
        <p>Modern software design increasingly revolves around <strong>asynchronous programming</strong> to allow
          programs to do more than one thing at a time. It used to be hard to write asynchronous code but it's gotten a
          lot easier. We'll explore further why asynchronous code matters and how to design code that avoids blocking,
          spinlocks and other processor power-wasting problems.</p>
      </article>
    </section>
    <section class="main-section" id="Prerequisites">
      <header>Prerequisites</header>
      <article>
        <p>Asynchronous JavaScript is a fairly advanced topic and you are advised to work through the first tutorials
          before attempting this:</p>
        <ul>
          <li><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps">JavaScript first steps</a>
          </li>
          <li><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks">JavaScript building
              blocks</a></li>
        </ul>
      </article>
    </section>
    <section class="main-section" id="Introducing_async_JavaScript">
      <header>Introducing async JavaScript</header>

      <h2>Synchronous JavaScript</h2>
      <p>To understand what asynchronous code is, we need to understand what synchronous code is. In this block of code,
        the lines are executed one after the other:</p>

      <pre class="prettyprint"><code>
        const btn = document.querySelector('button');
        btn.addEventListener('click', () => {
          alert('You clicked me!');

          let pElem = document.createElement('p');
          pElem.textContent = 'This is a newly-added paragraph';
          document.body.appendChild(pElem);
        });
      </code></pre>

      <p>While each operation is being processed, nothing else will happen (rendering is paused). This is because
        client-side JavaScript is single-threaded blocking language: only one thing can happen at once, on a single main
        thread. Everything else is blocked until the current operation completes.</p>

      <h2>Asynchronous JavaScript</h2>
      <p>To avoid such blocking, many Web APIs now use asynchronous code, especially for fetching resources from an
        external device (accessing a database and returning data from it, for instance). There are two main types of
        asynchronous code:</p>
      <ul>
        <li>old-style callbacks</li>
        <li>newer-style promises</li>
      </ul>

      <h3>Async callbacks</h3>
      <p>Callbacks are functions that are passed as parameters to other functions to be executed whena previous
        operation has returned. The second parameter of <code>addEventListener()</code> is an example:</p>
      <pre class="prettyprint"><code>
        btn.addEventListener('click', () => console.log('I am the callback!'));
      </code></pre>
      <p>The first paramater is the type of event to be listened for, and the second parameter is the function that is
        invoked when the event is fired.</p>
      <p>When we pass a callback function to another function, we only pass the function definition as the parameter, so
        that this callback function is not executed immediately. It is "called back" (hence the name) asynchronously,
        somewhere inside the containing function's body. The containing function is responsible for executing the
        callback function when the time comes.</p>
      <pre class="prettyprint"><code>
        function loadAsset(url, type, callback) {
          let xhr = new XMLHttpRequest();
          xhr.open('GET', url);
          xhr.responseType = type;
          xhr.onload = () => callback(xhr.response);
          xhr.send();
        }

        function displayImage(blob) {
          //displaying the resource on the user interface
        }

        loadAsset('../images/coffee.jpg', 'blob', displayImage);
      </code></pre>
      <p>Here the <code>displayImage()</code> function creates an image from the url's target and appends it to the
        document. The resource is fetched by the <code>loadAsset()</code> function and it passes the response to the
        callback to do something with it.</p>
      <p>Callbacks are versatile, they allow you to control the order in which functions are run, but also how and what
        data is passed between them. Note that some callbacks run synchronously, like when
        <code>Array.prototype.forEach()</code> loops through the items of an array.</p>
      <pre class="prettyprint"><code>
        const gods = ['Apollo', 'Artemis', 'Hermes', 'Zeus', 'Helios'];

        gods.forEach((godName, index) => {
          console.log(`${index} - ${godName}`);
        });
      </code></pre>
      <p>In this case, <code>forEach()</code> takes a unique callback as parameter and it runs immediately, without
        waiting for
        anything.</p>

      <h3>Promises</h3>
      <p>Promises are the new style of async code, used in modern web APIs. The <code>fetch()</code> API is a good
        example. It is basically a more modern and efficient version of <code>XMLHttpRequest</code>:</p>
      <pre class="prettyprint"><code>
        fetch('../source/products.json')
          .then((response) => response.json())
          .then((json) => {
            products = json;
            initialize();
          })
          .catch((error) => console.log(`Fetch problem: ${error.message}`));
      </code></pre>
      <p><code>fetch()</code> takes a single parameter, the url of the resource to fetch from the network, and returns a
        promise. The promise is an object representing the result (completion or failure) of the async operation. It
        represents an intermediate state. In essence, it's the browser's way of saying: "I promise to get back to you
        with the answer as soon as I can". Then we've got three further code blocks chained onto the end of the
        <code>fetch()</code> operation:</p>
      <ul>
        <li>Two <code>then()</code> blocks. Both contain a callback function that will run if the fetch operation is
          successful. Each callback receives the result returned by the previous successful operation. Each
          <code>then()</code> block returns a promise, meaning you can chain multiple <code>then()</code> blocks onto
          each other, so multiple async operations can be made to run in order.</li>
        <li>The <code>catch()</code> block, at the end, runs if any of the previous <code>then()</code> blocks fails. It
          is similar to <code>try {} catch {}</code>, an error object is made available inside which can be used to
          report the kind of error that has ocurred.</li>
      </ul>
      <p>Async operations like promises are put into an event queue, which runs after the main thread has finished
        processing and so <strong>does not block</strong> subsequent JavaScript code from running. The queued operations
        will complete as soon as possible then return their results to the JavaScript environment.</p>
      <h3>Conclusion</h3>
      <p>At its most basic, JavaScript is a synchronous, blocking, single-threaded language: only one action can be in
        progress at a time. But web browsers define functions and APIs that allow us to register functions that should
        not be executed synchronously but when some kind of event occurs (passage of time, user's interaction with the
        mouse, arrival of data from the network, etc.). It means that you can let your code do several things at the
        same time without blocking the main thread.</p>
    </section>

    <section class="main-section" id="Async_loops_and_intervals">
      <header>Async loops and intervals</header>
      <p>For a long time, JavaScript has made available a number of functions that allow you to asynchronously execute
        code after a certain time interval has elapsed, and repeatedly execute a block of code periodically until you
        tell it to stop. These are:</p>
      <ul>
        <li><code>setTimeout()</code> &mdash; Execute a specified block of code once after a specified time has elapsed.
        </li>
        <li><code>setInterval()</code> &mdash; Execute a specified block of code repeatedly with a fixed time delay
          between each call.</li>
        <li><code>requestAnimationFrame()</code> &mdash; The modern version of <code>setInterval()</code>, it executes a
          specified block of code before the browser next repaints the display, allowing an animation to be run at a
          suitable framerate, regardless of the environment it is being run in.</li>
      </ul>
      <p>These functions actually run on the main thread, but you're able to run other code between iterations to a more
        or less efficient degree, depending on how processor intensive these operations are. These functions are used
        for running constant animations and other background processing on a web site or application.</p>

      <h2>setTimeout()</h2>
      <p><code>setTimeout()</code> executes a specified block of code once after a specified time has elapsed. It takes
        the following parameters:</p>
      <ul>
        <li>A function to run, or a reference to a function defined elsewhere.</li>
        <li>A number representing the number of milliseconds to wait before executing that function. If you specify a
          value or 0 or omit the number, then the function will run immediately.</li>
        <li>Zero or more values that represent the parameters you want to pass to the function when it is run.</li>
      </ul>
      <p>Here, the browser will wait for 2 seconds and display an alert message:</p>
      <pre class="prettyprint"><code>
        const myGreeting = setTimeout(() => {
          alert('Hello Mr Universe!');
        }, 2000);
      </code></pre>
      <p>The function could be named and even defined somewhere else:</p>
      <pre class="prettyprint"><code>
        function sayHi() {
          alert('Hello Mr Universe!');
        }

        const myGreeting = setTimeout(sayHi, 2000);
      </code></pre>
      <p><code>setTimeout()</code> returns an identifier value that can be used to refer to the timeout later, to stop
        it for instance (see "Clearing timeouts", below).</p>
      <h3>Passing parameters to a setTimeout() function</h3>
      <p>Any parameter we want to pass to the function being run inside <code>setTimeout()</code> have to be passed as
        additional parameters, at the end of the list:</p>
      <pre class="prettyprint"><code>
        function sayHi(who) {
          alert(`Hello ${who}!`);
        }

        let myGreeting = setTimeout(sayHi, 2000, 'Mr Universe');
      </code></pre>
      <p>The name of the person to say hello is passed as a third parameter.</p>
      <h3>Clearing timeouts</h3>
      <p>Finally, if a timeout has been created, you can cancel it before the specified time has elapsed by calling
        <code>clearTimeout()</code> and passing it the identifier of the <code>setTimeout()</code> call as a parameter:
      </p>
      <pre class="prettyprint"><code>
        clearTimeout(myGreeting);
      </code></pre>

      <h2>setInterval()</h2>
      <p><code>setInterval()</code> runs a block of code over and over again. It works in a similar way to
        <code>setTimeout()</code>, except that the function passed to it as first parameter is executed repeatedly at an
        interval equal to the number of milliseconds provided as the second parameter. You can also pass any parameters
        required by the function being executed in as subsequent parameters of the <code>setInterval()</code> call.</p>
      <p>The following function creates a new <code>Date()</code> object, extracts a time string out of it, using
        <code>toLocaleTimeString()</code> and then displays it in the UI. We then run it once per second using
        <code>setInterval()</code>, creating the effect of a digital clock that updates once per second.</p>
      <pre class="prettyprint"><code>
        function displayTime() {
          let date = new Date();
          let time = date.toLocaleTimeString();
          document.getElementById('demo').textContent = time;
        }

        const createClock = setInterval(displayTime, 1000);
      </code></pre>

      <h3>Clearing intervals</h3>
      <p><code>setInterval()</code> keeps running a task forever. We may want to stop such tasks to prevent errors when
        the browser can't complete a cycle or of the animation being handled has finished. We can do it the same way as
        we stopped timeouts, by passing the identifier returned by <code>setInterval()</code> to the
        <code>clearInterval()</code> function:</p>
      <pre class="prettyprint"><code>
        const myInterval = setInterval(myFunction, 2000);

        clearInterval(myInterval);
      </code></pre>

      <h2>Things to keep in mind about setTimeout() and setInterval()</h2>
      <h3>Recursive timeouts</h3>
      <p><code>setTimeout()</code> can be called recursively to run the same code repeatedly, instead of using
        <code>setInterval()</code>. Here is an illustration:</p>
      <pre class="prettyprint"><code>
        let i = 1;
        setTimeout(function run() => {
          console.log(i);
          i++;
          setTimeout(run, 100);
        }, 100);
      </code></pre>
      <p>Here is the version using <code>setInterval()</code>:</p>
      <pre class="prettyprint"><code>
        let i = 1;
        setInterval(() => {
          console.log(i);
          i++;
        }, 100);
      </code></pre>
      <p>The difference between the two versions of the code is a subtle one</p>
      <ul>
        <li>Recursive <code>setTimeout()</code> guarantees a 100 ms delay between the executions. The code will run and
          then wait 100 milliseconds before it runs again. The interval will be the same regardless of how long the code
          takes to run.</li>
        <li><code>setInterval()</code> does things somewhat differently. The interval we choose <em>includes</em> the
          time taken to execute the code we want to run in. Let's say the code takes 40 milliseconds to run, then the
          interval ends up being only 60 milliseconds.</li>
      </ul>
      <p>When your code has the potential to take longer to run than the time interval you've assigned, it's better to
        use recursive <code>setTimeout()</code>. This will keep the time interval constant between executions regardless
        of how long the code takes to execute, and you won't get errors.</p>

      <h3>Immediate timeouts</h3>
      <p>Using 0 as the value of <code>setTimeout()</code> schedules the execution of the passed function as soon as
        possible, but only after the main thread has been run. In the following code, the alert "World" will only run
        after clicking OK on the alert "Hello":</p>
      <pre class="prettyprint"><code>
        setTimeout(() => alert('World'), 0);
        alert('Hello');
      </code></pre>
      <p>This can be useful in cases where you want to set a block of code to run as soon as all of the main thread has
        finished running. Put it on the async event loop, so it will run straight afterward.</p>

      <h3>Clearing with clearTimeout() or clearInterval()</h3>
      <p><code>clearInterval()</code> and <code>clearTimeout()</code> use the same list of entries to clear from.
        Interestingly enough, this means that you can use either method to clear a <code>setTimeout()</code> or
        <code>setInterval()</code>. But to avoid confusion and for consistency, use the appropriate method.</p>

      <h2>requestAnimationFrame()</h2>
      <p><code>requestAnimationFrame()</code> is a specialized looping function created for running animations in the
        browser. It is basically the modern version of <code>setInterval()</code>. It executes a specified block of code
        before the browser next repaints the display, allowing an animation to be run at a suitable framerate regardless
        of the environment it is being run in.</p>
      <p>The method takes a callback to be invoked before the repaint as argument. This is the general pattern you'll
        see it used:</p>
      <pre class="prettyprint"><code>
        function draw() {
          // Drawing code goes here
          requestAnimationFrame(draw);
        }

        draw();
      </code></pre>
      <p>The idea is that you define a function in which your animation is updated, then you call it to start the
        process off. At the end of the function block, you call <code>requestAnimationFrame()</code> with the function
        reference passed as the parameter and this instructs the browser to call the function again on the next display
        repaint. This is then run continuously, as we are calling <code>requestAnimationFrame()</code> recursively.</p>
      <p>We don't specify a time interval for <code>requestAnimationFrame()</code>. It just runs as fast and smoothly as
        possible in the current conditions (as close as possible to 60 fps - frames per second). The browser doesn't
        waste time running the animation if it is offscreen, etc.</p>
      <h3>Including a timestamp</h3>
      <p>The callback passed to the <code>requestAnimationFrame()</code> function also accepts a parameter: a timestamp
        value that represents the time since the animation started running. This is useful as this allows to run things
        at specific times and at a constant pace, regardless of how fast or slow the device might be.</p>
      <pre class="prettyprint"><code>
        let startTime = null;
        function draw(timestamp) {
          if (!startTime) {
            startTime = timestamp;
          }
          currenTime = timestamp - startTime;
          // Do something based on current time
          requestAnimationFrame(draw);
        }
      </code></pre>
      <h3>Clearing a <code>requestAnimationFrame()</code> call</h3>
      <p>Clearing a <code>requestAnimationFrame()</code> can be done calling the corresponding
        <code>cancelAnimationFrame()</code>, passing it the value returned by the <code>requestAnimationFrame()</code>
        (stored in a variable)</p>
      <pre class="prettyprint"><code>
        cancelAnimationFrame(myRaF);
      </code></pre>

      <section class="main-section" id="Async_operations_with_Promises">
        <header>Async operations with Promises</header>
        <p>A promise is an object that represents an intermediate state of an operation: <em>a</em> promise that a
          result of some kind will be returned at some point in the future.</p>

        <h2>The trouble with callbacks</h2>
        <p>To fully understand why promises are a good thing, it helps to think back why old-style callbacks are
          problematic.</p>
        <p>Let's talk about ordering pizza as an analogy. There are certain steps that you have to take for your order
          to be successful, which don't really make sense to try to execute out of order, or in order but before each
          previous step has quite finished:</p>
        <ol>
          <li>You choose what pizza you want. This can take a while if you're indecisive and may fail if you can't make
            up your mind, or decide to get a curry instead.</li>
          <li>You then place your order. This can take a while to return a pizza and may fail if the restaurant does not
            have the required ingredients to cook it.</li>
          <li>You then collect your pizza and eat. This may fail if, says, you forgot your wallet so can't pay for the
            pizza!</li>
        </ol>
        <p>With old-style callbacks, a pseudo-code representation of the above functionality might look something like
          this:</p>
        <pre class="prettyprint"><code>
          choosePizza((order) => {
            placeOrder(order, (pizza) => {
              collectOrder(pizza, (enjoy) => {
                eatPizza(enjoy);
              }, failureCallback);
            }, failureCallback);
          }, failureCallback);
        </code></pre>
        <p>This is messy and hard to read (often referred to as "callback hell"). If this were real code, it would
          likely block the main thread until it completes and would require you to call the
          <code>failureCallback()</code> multiple times.</p>

        <h2>Improvements with promises</h2>
        <p>Promises make situation like the above much easier to write, parse and run. If we represented the above
          peudo-code using asynchronous promises instead, we'd end up with something like this:</p>
        <pre class="prettyprint"><code>
          choosePizza()
            .then(order => placeOrder(order))
            .then(pizza => collectOrder(pizza))
            .then(enjoy => eatPizza(enjoy))
            .catch(failureCallback);
        </code></pre>
        <p>This is much better. It is easier to see what's going on and a single <code>.catch()</code> block is needed
          to handle all the errors. It doesn't block the main thread and each operation is guaranteed to wait for
          previous operations to complete before running. We're able to chain multiple asynchronous actions to occur one
          after another because each <code>.then()</code> block returns a new promise that resolves when the
          <code>.then()</code> block is done running.</p>
        <p>At their most basic promises are similar to event listeners, but with a few differences:</p>
        <ul>
          <li>A promise can only succeed or fail once. It cannot succeed or fail twice and it cannot switch from success
            to failure or vice versa once the operation has completed.</li>
          <li>If a promise has succeeded or failed and you later add a success / failure callback, the correct callback
            will be called, even though the event took place earlier</li>
        </ul>

        <h2>Explaining basic promise syntax: a real example</h2>
        <p>Promises are important to understand because most modern Web APIs use them for returning values. Later on,
          we'll look at how to write your own promise, bu for now we'll look at some simple examples.</p>
        <p>In the first example, we'll use the <code>fetch()</code> method to fetch an image from the web, the
          <code>blob()</code> to transform the fetch response's raw body contents into a <code>Blob</code> object, and
          then display that blob inside and <code>&lt;img&gt;</code> element. This is very similar to the very first
          example we looked at in this page.</p>
        <pre class='prettyprint'><code>
          let promise = fetch('coffee.jpg');
        </code></pre>
        <p>This calls the <code>fetch()</code> method, passing it the url of the image to fetch from the network as a
          parameter. We are storing the promise object returned by <code>fetch()</code> inside a variable. This object
          represents an intermediate state that is initially neither success or failure. When a promise has not
          completed yet, we say it is <strong>pending</strong></p>
        <p>To respond to the successful completion of the operation, whenever that occurs (when a <code>Response</code>
          is returned in that case), we invoke the <code>then()</code> method of the promise object. The callback inside
          the <code>then()</code> block (referred to as the <strong>executor</strong>) runs only when the promise call
          completes successfully (when it is <strong>fulfilled</strong>, or <strong>resolved</strong>). It is passed the
          <code>Response</code> object as parameter. Note the <code>then()</code> doesn't run until an event occurs
          (when the promise fulfills). We immediately run the <code>blob()</code> method on this response to ensure that
          the response body is fully downloaded and then transform it into a blob object we can use.</p>
        <pre class='prettyprint'><code>
          let promise2 = promise.then(response => response.blob());
        </code></pre>
        <p>Each call to <code>then()</code> creates a new promise and the call to <code>blob()</code> also returns a
          promise. We can handle the <code>Blob</code> object stored in the second variable by invoking the
          <code>then()</code> method of the second promise.</p>
        <pre class='prettyprint'><code>
          let promise3 = promise2.then((myBlob) => {
            let objectURL = URL.createObjectURL(myBlob);
            let image = document.createElement('img');
            image.src = objectURL;
            document.body.appendChild(image);
          })
        </code></pre>
        <p>Here we are running the <code>URL.createObjectURL()</code> method. It is passed the <code>Blob</code> object
          returned by the second promise fulfillement, as a paramater. This will return a URL pointing to the object.
          Then we create an <code>&lt;img&gt;</code> element, set its <code>src</code> attribute to equal the object URL
          and append it to the DOM, so the image is displayed on the page.</p>
        <h3>Responding to failure</h3>
        <p>There is currently nothing to explicitly handle errors if one of the promises fails
          (<strong>rejects</strong>, in promise-speak). We can add error handling by running the <code>.catch()</code>
          method of the previous promise.</p>
        <pre class='prettyprint'><code>
          let errorCase = promise3.catch((error) => {
            console.log(`There has been a problem with your fetch operation: ${error.message}`);
          });
        </code></pre>
        <p>This allows us to control error handling exactly how we want. In a real app, your <code>catch()</code> block
          could retry fetching the image, or show a default image, or prompt the user to provide another url, or
          whatever.</p>
        <h3>Chaining the blocks together</h3>
        <p>You can shorten this code and chain together <code>then()</code> and <code>catch()</code> blocks. The above
          code could be written like this:</p>
        <pre class='prettyprint'><code>
          fetch('coffee.jpg')
            .then(response => response.blob())
            .then((myBlob) => {
              let objectURL = URL.createObjectURL(myBlob);
              let image = document.createElement('img');
              image.src = objectURL;
              document.body.appendChild(image);
            })
            .catch(error => console.log(`Error: ${error.message}`));
        </code></pre>
        <p>The value returned by the executor function passed to a <code>then()</code> block becomes the parameter
          passed to the next <code>then()</code> block's executor function. Note that <code>.then()</code> and
          <code>.catch()</code> blocks in promises are the async equivalent of a try...catch block in sync code.</p>

        <h2>Running code in response to multiple promises fulfilling</h2>
        <p>Let's look at some more advanced features. What if you want to run some code shortly after a whole bunch of
          promises have all fulfilled? You can do this with the <code>Pomise.all()</code> static method. It takes an
          array of promises as parameter and returns a new promise object that will fulfill only if all promises in the
          array fulfill:</p>
        <pre class='prettyprint'><code>
        Promise.all(p1, p2, p3)
          .then((values) => {
            // do something here
          });
      </code></pre>
        <p>If all promises fulfill, the executor function will be passed an array "values as parameter, containing all
          the results. If any of the promises passed to <code>Promise.all()</code> reject, the whole block will reject.
          This can be very useful if you're fetching information to dynamically populate a UI. It generally makes sense
          to receive all the data rather than displaying partial information.</p>
        <p>Here is a real world example:</p>
        <pre class='prettyprint'><code>
          function fetchAndDecode(url, type) {
            return fetch(url).then((response) => {
              if (type === 'blob') {
                return response.blob();
              } else if (type === 'text') {
                return response.text();
              }
            })
            .catch(error => console.log(`Fetching error: ${error.message}`));
          }

          let coffee = fetchAndDecode('coffee.jpg', 'blob');
          let tea = fetchAndDecode('tea.jpg', 'blob');
          let description = fetchAndDecode('description.txt', 'text');

          Promise.all([coffee, tea, description])
            .then((values) => {
              // store each value returned from the promises in separate variables,
              // create object URLs from the blobs
              let objectURL1 = URL.createObjectURL(values[0]);
              let objectURL2 = URL.createObjectURL(values[1]);
              let descText = values[2];

              // display the images in &lt;img&gt; elements
              let image1 = document.createElement('img');
              let image2 = document.createElement('img');
              image1.src = objectURL1;
              image2.src = objectURL2;
              document.appendChild(image1);
              document.appendChild(image2);

              // display the text in a paragraph
              let para = document.createElement('p');
              para.textContent = descText;
              document.appendChild(para);
            });
        </code></pre>
        <p>First, we define a function being passed a url and the type of resource being fetched (blob or text). Inside
          the function, we call the <code>fetch()</code> function to fetch the resource at the specified url. In this
          case, the second promise we chain on is different depending on what the <code>type</code> value is.
          Additionally, we don't run the promise chain in isolation, we have added the <code>return</code> keyword
          before the fetch call. The effect is to run the entire chain and then run the final result (the promise
          returned by <code>blob()</code> or <code>text()</code>) as the return value of the function just defined. In
          effect, the <code>return</code> statements pass the results back up the chain to the top.</p>
        <p>At the end of the block, we chain on a <code>.catch()</code> call, to handle any error that may come up with
          any of the promises passed in the array to <code>.all()</code>. If any of the promises reject, the catch block
          will let you know which one had a problem. The <code>.all()</code> block will still fulfill, but just won't
          display the resources that had problems. If you wanted the <code>.all()</code> to reject, you'd have to chain
          the <code>.catch()</code> block on to the end of it instead.</p>
        <p>Next, we call our function three times to begin the process of fetching and decoding the images and text.
          Each of the returned promises is stored in a variable. Then we define a <code>Promise.all()</code> block to
          run some code only when all three of the promises stored above have successfully fulfilled. The executor
          inside the <code>.then()</code> will be passed an array containing the results from the individual promises
          (decoded response bodies).</p>

        <h2>Running some final code after a promise fulfills / rejects</h2>
        <p>There will be cases where you want to run a final block of code after a promise completes, regardless of
          whether it fulfilled or rejected. The <code>.finally()</code> can be chained onto the end of the regular
          promise chain, allowing you to cut down on code repetition of adding this final code to the end of both the
          <code>.then()</code> and <code>.catch()</code> blocks.</p>
        <pre class='prettyprint'><code>
          myPromise
            .then(response => doSomething(response))
            .catch(error => handleError(error))
            .finally(() => runFinalCode());
        </code></pre>
        <p>In a real example, this would look like this:</p>
        <pre class='prettyprint'><code>
          function fetchAndDecode(url, type) {
            return fetch(url).then((response) => {
              if (type === 'blob') {
                return response.blob();
              } else if (type === 'text') {
                return response.text();
              }
            })
            .catch(error => console.log(`Fetch failed: ${error.message}`))
            .finally(() => console.log(`Fetch attempt for ${url} finished.`))
          }
        </code></pre>

        <h2>Building your own custom promises</h2>
        <p>Combining different promise-based APIs together to create custom functionality is by far the most common way
          you'll do custom things with promises. There is another way, however.</p>

        <h3>Using the Promise() constructor</h3>
        <p>It is possible to build your own promises using the <code>Promise()</code> constructor. The main situation in
          which you'll want to do this is when you've got code based on an old-school asynchronous API that is not
          promise-based, which you want to promis-ify.</p>
        <p>Here is a simple example, where we wrap a <code>setTimeout()</code> with a promise. This runs a function
          after two seconds that resolves the promise with a string of "Success!".</p>
        <pre class="prettyprint"><code>
        let timeoutPromise = new Promise((resolve, reject) => {
          setTimeout(() => {
            resolve("Success!");
          }, 2000);
        });
      </code></pre>
        <p><code>resolve()</code> and <code>reject()</code> are functions that you call to resolve or reject the
          newly-created promise. So, when you call this promise, you can chain a <code>.then()</code> block onto its end
          an it will be passed the "Success!" string. In the below code, we simply alert that message:</p>
        <pre class="prettyprint"><code>
        timeoutPromise()
          .then(message => alert(message));
      </code></pre>
        <p>or even just:</p>
        <pre class="prettyprint"><code>
        timeoutPromise().then(alert);
      </code></pre>

        <h3>Rejecting a custom promise</h3>
        <p>We can create a promise that rejects using the <code>reject()</code> method, taking a single value: the value
          to reject with, i.e. the error passed into the <code>.catch()</code> block.</p>
        <pre class="prettyprint"><code>
        function timeoutPromise(message, interval) {
          return new Promise((resolve, reject) => {
            if (message === '' || typeof message !== 'string') {
              reject("Message is empty or not a string.");
            } else if (interval &lt; 0 || typeof interval !== 'number') {
              reject("Interval is negative or not a number.");
            } else {
              setTimeout(() => resolve(message), interval);
            }
          })
        }
      </code></pre>
        <p>Here we are passing two values into a custom function, a message to do something with and a time interval
          before doing this thing. Inside the function, we return a new <code>Promise</code> object. Invoking the
          function will return the promise we want to use. Inside this Promise constructor, we do a number of checks:
        </p>
        <ol>
          <li>We check to see if the message is appropriate for being alerted. If it's an empty string or not a string
            at all, we reject the promise with a suitable error message</li>
          <li>Next, we check to see if the interval is an appropriate interval value. If it's negative or not a number,
            we reject the promise with a suitable error message.</li>
          <li>Finally, if the parameters are ok, we resolve the promise with the specified message after the specified
            interval has passed using <code>setTimeout()</code>.</li>
        </ol>
        <p>Since the <code>timeoutPromise()</code> function returns a <code>Promise</code>, we can chain
          <code>.then()</code>, <code>.catch()</code> blocks onto it to make use of its functionality.</p>
        <pre class="prettyprint"><code>
        timeoutPromise('Hello there!', 1000)
          .then(message => alert(message))
          .catch(error => console.log(error));
      </code></pre>

        <h3>A more real-world example</h3>
        <p>In the above example, the async nature is faked using <code>setTimeout()</code>. One example we'd like to
          invite you to study is <a href="https://github.com/jakearchibald/idb/" target="_blank"
            rel="noopener noreferrer">Jake Archibald's idb library</a>. This takes the IndexedDB API, which is an
          old-style callback-based API for storing and retrieving data on the client-side, and allows you to use it with
          promises. The following block converts the basice request model used by many IndexedDB methods to use
          promises:</p>
        <pre class="prettyprint"><code>
          function promisifyRequest(request){
            return new Promise((resolve, reject) => {
              request.onsuccess = () => resolve(request.result);
              request.onerror = () => reject(request.error);
            });
          }
        </code></pre>

        <h2>Conclusion</h2>
        <p>Promises are a good way to build asynchronous applications when we don't know the return value of a function
          or how long it will take to return. They make it easier to express and reason about sequences of asynchronous
          operations without deeply nested callbacks. And they support a style of error handling that is similar to the
          synchronous try / catch statement. We didn't touch on all promise features in this article, just the most
          interesting and useful ones. Most of modern Web APIs are promise-based, so you'll need to understand promises
          to get the most out of them. Among those APIs are WebRTC, Web Audio, Media Capture and Streams. Promises will
          be more and more important as time goes on, so learning to use and understand them is an important step in
          learning modern JavaScript.</p>
      </section>
      <section class="main-section" id="Easier_async_programming_with_async_await">
        <header>Easier async programming with async await</header>
        <p><code>async</code> functions and the <code>await</code> keyword are part of the ECMAScript 2017 JavaScript
          edition. These features are basically synctatic sugar on top of promises, making async code easier to write
          and to read afterward. They make async code look more like old-school sync code.</p>

        <h2>The basics of async / await</h2>
        <p>There are two parts to async / await.</p>
        <h3>The async keyword</h3>
        <p>First of all, we have the <code>async</code> keyword, which you put in front of a function declaration to
          turn it into an async function. Try typing these lines into the browser's JavaScript console:</p>
        <pre class="prettyprint"><code>
          function hello() {
            return 'Hello!';
          }
          hello();
        </code></pre>
        <p>The function returns "Hello!", nothing special. But if you turn it into an async function:</p>
        <pre class="prettyprint"><code>
          async function hello() {
            return 'Hello!';
          }
          hello();
        </code></pre>
        <p>Invoking the function now returns a promise. You can also create an <code>async</code> function like so:</p>
        <pre class="prettyprint"><code>
          let hello = async () => 'Hello!';
          hello();
        </code></pre>
        <p>To actually consume the value returned when the promise fulfills, since it's returning a promise, we cound
          use a <code>.then()</code> block.</p>
        <pre class="prettyprint"><code>
          hello()
            .then(value => console.log(value));
        </code></pre>
        <p>or even just a shorthand such as:</p>
        <pre class="prettyprint"><code>
          hello().then(console.log);
        </code></pre>

        <h3>The await keyword</h3>
        <p>The real advantage of the <code>async</code> functions becomes apparent when you combine it with the
          <code>await</code> keyword. This can be put in front of any <code>async</code> promise-based function to make
          the code execution pause on that line until the promise fulfills, then the fulfillement value is returned.
          Here is a trivial example:</p>
        <pre class="prettyprint"><code>
          async function hello() {
            return greeting = await Promise.resolve('Hello!');
          }
          hello().then(alert);
        </code></pre>

        <h2>Rewriting promise code with async await</h2>
        <p>Let's look back at a simple fetch example.</p>
        <pre class="prettyprint"><code>
          fetch('coffee.jpg')
            .then(response => response.blob())
            .then((myBlob) => {
              let objectURL = URL.createObjectURL(myBlob);
              let image = document.createElement('img');
              image.src = objectURL;
              document.appendChild(image);
            })
            .catch(error => console.log(`Error while fetching: ${error.message}`));
        </code></pre>
        <p>Let's convert this to use async / await to see how much simpler it makes things.</p>
        <pre class="prettyprint"><code>
          async function myFetch() {
            let response = await fetch('coffee.jpg');
            let myBlob = await response.blob();

            let objectURL = URL.createObjectURL(myBlob);
            let image = document.createElement('img');
            image.src = objectURL;
            document.appendChild(image);
          }
        </code></pre>
        <p>It makes code much simpler and easier to understand. No more <code>.then()</code> blocks everywhere!</p>
        <p>Since the <code>async</code> keyword turns a function into a promise, you could refactor your code to use a
          hybrid approach of promises and <code>await</code>, bringing the second half of the function out into a new
          block, to make it more flexible:</p>
        <pre class="prettyprint"><code>
          async function myFetch() {
            let response = await fetch('coffee.jpg');
            return await response.blob();
          }

          myFetch()
           .then((blob) => {
              let objectURL = URL.createObjectURL(myBlob);
              let image = document.createElement('img');
              image.src = objectURL;
              document.body.appendChild(image);
           });
        </code></pre>

        <h3>But how does it work?</h3>
        <p>It is necessary to wrap the code inside a function and to include the <code>async</code> keyword before the
          <code>function</code> keyword. You have to create an async function to define a block of code in which you'll
          run your async code; <code>await</code> only works inside of async functions.</p>
        <p>Inside the <code>myFetch()</code> function, instead of needing to chain a <code>.then()</code> block on to
          the end of each promise-based method, you just need to add an <code>await</code> keyword before the method
          call and then assign the result to a variable. The <code>await</code> keyword causes the JavaScript parser to
          pause on this line until the async call has returned its result, then once it is complete, move on to the next
          line. So, for example:</p>
        <pre class="prettyprint"><code>
          let response = await fetch('coffee.jpg');
        </code></pre>
        <p>The response returned by <code>fetch()</code> is assigned to a variable when it is available, and the parser
          pauses on this line until that occurs. Once the response is available, the parser moves to the next line,
          which creates a blob out of it. This line also invokes an async promise-based method, so we use
          <code>await</code> there as well. When the result of the operation returns, we return if out of the
          <code>myFetch()</code> function.</p>
        <p>This means that when we call the <code>myFetch()</code> function, it returns a promise, so we can chain a
          <code>.then()</code> onto the end of it, inside which we handle displaying the blob onscreen.</p>

        <h3>Adding error handling</h3>
        <p>If you want to add error handling, you've got a couple of options. You can use the familiar sync try / catch
          structure:</p>
        <pre class="prettyprint"><code>
          async function myFetch() {
            try {
              let response = await fetch('coffee.jpg');
              let myBlob = await response.blob();

              let objectURL = URL.createObjectURL(myBlob);
              let image = document.createElement('img');
              image.src = objectURL;
              document.body.appendChild(image);
            } catch(error) {
              console.log(error);
            }
          }

          myFetch();
        </code></pre>
        <p>The <code>catch()</code> block is passed an error object that can be logged to the console. Using the
          refactored hybrid version of the code, you'd be better off chaining a <code>.catch()</code>block onto the end
          of the <code>.then()</code> block like this:</p>
        <pre class="prettyprint"><code>
          async function myFetch() {
            let response = await fetch('coffee.jpg');
            return await response.blob();
          }

          myFetch()
           .then((blob) => {
              let objectURL = URL.createObjectURL(myBlob);
              let image = document.createElement('img');
              image.src = objectURL;
              document.body.appendChild(image);
           })
           .catch(error => console.log(error));
        </code></pre>
        <p>This is because the <code>.catch()</code> block will catch errors occurring in both the async function call
          and the promise chain. If you used the try / catch block here, you might still get unhandled errors in the
          <code>myFetch()</code> function when called.</p>
        
        <h2>Awaiting a promise.all</h2>
        <p></p>
      </section>
  </main>

  <footer>
    <p>This page was extracted from the <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous"
        target="_blank" rel="noopener noreferrer">Mozilla Developer Network</a> documentation</p>
  </footer>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?skin=desert"></script>
  <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
</body>

</html>