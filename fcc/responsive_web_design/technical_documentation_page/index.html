<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Technical documentation page</title>
  <link rel="stylesheet" href="style/style.css">
</head>

<body>
  <nav id="navbar">
    <header>Asynchronous JavaScript</header>
    <ul>
      <a href="#Introduction" class="nav-link" rel="internal">
        <li>Introduction</li>
      </a>
      <a href="#Prerequisites" class="nav-link" rel="internal">
        <li>Prerequisites</li>
      </a>
      <a href="#Introducing_async_JavaScript" class="nav-link" rel="internal">
        <li>Introducing async JavaScript</li>
      </a>
      <a href="#Async_loops_and_intervals" class="nav-link" rel="internal">
        <li>Async loops and intervals</li>
      </a>
      <a href="#Async_operations_with_Promises" class="nav-link" rel="internal">
        <li>Async operations with Promises</li>
      </a>
      <a href="#Easier_async_programming_with_async_await" class="nav-link" rel="internal">
        <li>Easier async programming with async await</li>
      </a>
    </ul>
  </nav>

  <main id="main-doc">
    <section class="main-section" id="Introduction">
      <header>Introduction</header>
      <article>
        <p>Asynchronous JavaScript is used to effectively handle potential blocking operations such as fetching
          resources from a server. When only one thing happens at once, a function depending on another function has to
          wait for the other function to finish and return. From the perspective of the user, the program is essentially
          stopped during that time and a spinning cursor on the screen is generally visible.</p>
        <p>This is a frustrating experience and a waste of computing processing power.Asynchronous programming lets you
          get other work done in the meantime. This is important in the case of web browsers. When a web app runs in a
          browser and it executes and intensive chunk of code without returning control to the browser, this one can
          appear to be frozen. This is called <strong>blocking</strong>: the browser is prevented from handling user
          input.</p>
        <p>Modern software design increasingly revolves around <strong>asynchronous programming</strong> to allow
          programs to do more than one thing at a time. It used to be hard to write asynchronous code but it's gotten a
          lot easier. We'll explore further why asynchronous code matters and how to design code that avoids blocking,
          spinlocks and other processor power-wasting problems.</p>
      </article>
    </section>
    <section class="main-section" id="Prerequisites">
      <header>Prerequisites</header>
      <article>
        <p>Asynchronous JavaScript is a fairly advanced topic and you are advised to work through the first tutorials
          before attempting this:</p>
        <ul>
          <li><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps">JavaScript first steps</a>
          </li>
          <li><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks">JavaScript building
              blocks</a></li>
        </ul>
      </article>
    </section>
    <section class="main-section" id="Introducing_async_JavaScript">
      <header>Introducing async JavaScript</header>

      <h2>Synchronous JavaScript</h2>
      <p>To understand what asynchronous code is, we need to understand what synchronous code is. In this block of code,
        the lines are executed one after the other:</p>

      <pre class="prettyprint"><code>
        const btn = document.querySelector('button');
        btn.addEventListener('click', () => {
          alert('You clicked me!');

          let pElem = document.createElement('p');
          pElem.textContent = 'This is a newly-added paragraph';
          document.body.appendChild(pElem);
        });
      </code></pre>

      <p>While each operation is being processed, nothing else will happen (rendering is paused). This is because
        client-side JavaScript is single-threaded blocking language: only one thing can happen at once, on a single main
        thread. Everything else is blocked until the current operation completes.</p>

      <h2>Asynchronous JavaScript</h2>
      <p>To avoid such blocking, many Web APIs now use asynchronous code, especially for fetching resources from an
        external device (accessing a database and returning data from it, for instance). There are two main types of
        asynchronous code:</p>
      <ul>
        <li>old-style callbacks</li>
        <li>newer-style promises</li>
      </ul>

      <h3>Async callbacks</h3>
      <p>Callbacks are functions that are passed as parameters to other functions to be executed whena previous
        operation has returned. The second parameter of <code>addEventListener()</code> is an example:</p>
      <pre class="prettyprint"><code>
        btn.addEventListener('click', () => console.log('I am the callback!'));
      </code></pre>
      <p>The first paramater is the type of event to be listened for, and the second parameter is the function that is
        invoked when the event is fired.</p>
      <p>When we pass a callback function to another function, we only pass the function definition as the parameter, so
        that this callback function is not executed immediately. It is "called back" (hence the name) asynchronously,
        somewhere inside the containing function's body. The containing function is responsible for executing the
        callback function when the time comes.</p>
      <pre class="prettyprint"><code>
        function loadAsset(url, type, callback) {
          let xhr = new XMLHttpRequest();
          xhr.open('GET', url);
          xhr.responseType = type;
          xhr.onload = () => callback(xhr.response);
          xhr.send();
        }

        function displayImage(blob) {
          //displaying the resource on the user interface
        }

        loadAsset('../images/coffee.jpg', 'blob', displayImage);
      </code></pre>
      <p>Here the <code>displayImage()</code> function creates an image from the url's target and appends it to the
        document. The resource is fetched by the <code>loadAsset()</code> function and it passes the response to the
        callback to do something with it.</p>
      <p>Callbacks are versatile, they allow you to control the order in which functions are run, but also how and what
        data is passed between them. Note that some callbacks run synchronously, like when
        <code>Array.prototype.forEach()</code> loops through the items of an array.</p>
      <pre class="prettyprint"><code>
        const gods = ['Apollo', 'Artemis', 'Hermes', 'Zeus', 'Helios'];

        gods.forEach((godName, index) => {
          console.log(`${index} - ${godName}`);
        });
      </code></pre>
      <p>In this case, <code>forEach()</code> takes a unique callback as parameter and it runs immediately, without
        waiting for
        anything.</p>

      <h3>Promises</h3>
      <p>Promises are the new style of async code, used in modern web APIs. The <code>fetch()</code> API is a good
        example. It is basically a more modern and efficient version of <code>XMLHttpRequest</code>:</p>
      <pre class="prettyprint"><code>
        fetch('../source/products.json')
          .then((response) => response.json())
          .then((json) => {
            products = json;
            initialize();
          })
          .catch((error) => console.log(`Fetch problem: ${error.message}`));
      </code></pre>
      <p><code>fetch()</code> takes a single parameter, the url of the resource to fetch from the network, and returns a
        promise. The promise is an object representing the result (completion or failure) of the async operation. It
        represents an intermediate state. In essence, it's the browser's way of saying: "I promise to get back to you
        with the answer as soon as I can". Then we've got three further code blocks chained onto the end of the
        <code>fetch()</code> operation:</p>
      <ul>
        <li>Two <code>then()</code> blocks. Both contain a callback function that will run if the fetch operation is
          successful. Each callback receives the result returned by the previous successful operation. Each
          <code>then()</code> block returns a promise, meaning you can chain multiple <code>then()</code> blocks onto
          each other, so multiple async operations can be made to run in order.</li>
        <li>The <code>catch()</code> block, at the end, runs if any of the previous <code>then()</code> blocks fails. It
          is similar to <code>try {} catch {}</code>, an error object is made available inside which can be used to
          report the kind of error that has ocurred.</li>
      </ul>
      <p>Async operations like promises are put into an event queue, which runs after the main thread has finished
        processing and so <strong>does not block</strong> subsequent JavaScript code from running. The queued operations
        will complete as soon as possible then return their results to the JavaScript environment.</p>
      <h3>Conclusion</h3>
      <p>At its most basic, JavaScript is a synchronous, blocking, single-threaded language: only one action can be in
        progress at a time. But web browsers define functions and APIs that allow us to register functions that should
        not be executed synchronously but when some kind of event occurs (passage of time, user's interaction with the
        mouse, arrival of data from the network, etc.). It means that you can let your code do several things at the
        same time without blocking the main thread.</p>
    </section>

    <section class="main-section" id="Async_loops_and_intervals">
      <header>Async loops and intervals</header>
      <p>For a long time, JavaScript has made available a number of functions that allow you to asynchronously execute
        code after a certain time interval has elapsed, and repeatedly execute a block of code periodically until you
        tell it to stop. These are:</p>
      <ul>
        <li><code>setTimeout()</code> &mdash; Execute a specified block of code once after a specified time has elapsed.
        </li>
        <li><code>setInterval()</code> &mdash; Execute a specified block of code repeatedly with a fixed time delay
          between each call.</li>
        <li><code>requestAnimationFrame()</code> &mdash; The modern version of <code>setInterval()</code>, it executes a
          specified block of code before the browser next repaints the display, allowing an animation to be run at a
          suitable framerate, regardless of the environment it is being run in.</li>
      </ul>
      <p>These functions actually run on the main thread, but you're able to run other code between iterations to a more
        or less efficient degree, depending on how processor intensive these operations are. These functions are used
        for running constant animations and other background processing on a web site or application.</p>

      <h2>setTimeout()</h2>
      <p><code>setTimeout()</code> executes a specified block of code once after a specified time has elapsed. It takes
        the following parameters:</p>
      <ul>
        <li>A function to run, or a reference to a function defined elsewhere.</li>
        <li>A number representing the number of milliseconds to wait before executing that function. If you specify a
          value or 0 or omit the number, then the function will run immediately.</li>
        <li>Zero or more values that represent the parameters you want to pass to the function when it is run.</li>
      </ul>
      <p>Here, the browser will wait for 2 seconds and display an alert message:</p>
      <pre class="prettyprint"><code>
        const myGreeting = setTimeout(() => {
          alert('Hello Mr Universe!');
        }, 2000);
      </code></pre>
      <p>The function could be named and even defined somewhere else:</p>
      <pre class="prettyprint"><code>
        function sayHi() {
          alert('Hello Mr Universe!');
        }

        const myGreeting = setTimeout(sayHi, 2000);
      </code></pre>
      <p><code>setTimeout()</code> returns an identifier value that can be used to refer to the timeout later, to stop
        it for instance (see "Clearing timeouts", below).</p>
      <h3>Passing parameters to a setTimeout() function</h3>
      <p>Any parameter we want to pass to the function being run inside <code>setTimeout()</code> have to be passed as
        additional parameters, at the end of the list:</p>
      <pre class="prettyprint"><code>
        function sayHi(who) {
          alert(`Hello ${who}!`);
        }

        let myGreeting = setTimeout(sayHi, 2000, 'Mr Universe');
      </code></pre>
      <p>The name of the person to say hello is passed as a third parameter.</p>
      <h3>Clearing timeouts</h3>
      <p>Finally, if a timeout has been created, you can cancel it before the specified time has elapsed by calling
        <code>clearTimeout()</code> and passing it the identifier of the <code>setTimeout()</code> call as a parameter:
      </p>
      <pre class="prettyprint"><code>
        clearTimeout(myGreeting);
      </code></pre>

      <h2>setInterval()</h2>
      <p><code>setInterval()</code> runs a block of code over and over again. It works in a similar way to
        <code>setTimeout()</code>, except that the function passed to it as first parameter is executed repeatedly at an
        interval equal to the number of milliseconds provided as the second parameter. You can also pass any parameters
        required by the function being executed in as subsequent parameters of the <code>setInterval()</code> call.</p>
      <p>The following function creates a new <code>Date()</code> object, extracts a time string out of it, using
        <code>toLocaleTimeString()</code> and then displays it in the UI. We then run it once per second using
        <code>setInterval()</code>, creating the effect of a digital clock that updates once per second.</p>
      <pre class="prettyprint"><code>
        function displayTime() {
          let date = new Date();
          let time = date.toLocaleTimeString();
          document.getElementById('demo').textContent = time;
        }

        const createClock = setInterval(displayTime, 1000);
      </code></pre>

      <h3>Clearing intervals</h3>
      <p><code>setInterval()</code> keeps running a task forever</p>
    </section>
    <section class="main-section" id="Async_operations_with_Promises">
      <header>Async operations with Promises</header>
    </section>
    <section class="main-section" id="Easier_async_programming_with_async_await">
      <header>Easier async programming with async await</header>
    </section>
  </main>

  <footer>
    <p>This page was built using the <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous"
        target="_blank" rel="noopener noreferrer">Mozilla Developer Network</a> documentation</p>
  </footer>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?skin=desert"></script>
  <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
</body>

</html>