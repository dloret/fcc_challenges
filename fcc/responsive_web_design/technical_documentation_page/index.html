<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Technical documentation page</title>
  <link rel="stylesheet" href="style/style.css">
</head>

<body>
  <nav id="navbar">
    <header>Asynchronous JavaScript</header>
    <ul>
      <a href="#Introduction" class="nav-link" rel="internal">
        <li>Introduction</li>
      </a>
      <a href="#Prerequisites" class="nav-link" rel="internal">
        <li>Prerequisites</li>
      </a>
      <a href="#Introducing_async_JavaScript" class="nav-link" rel="internal">
        <li>Introducing async JavaScript</li>
      </a>
      <a href="#Async_loops_and_intervals" class="nav-link" rel="internal">
        <li>Async loops and intervals</li>
      </a>
      <a href="#Async_operations_with_Promises" class="nav-link" rel="internal">
        <li>Async operations with Promises</li>
      </a>
      <a href="#Easier_async_programming_with_async_await" class="nav-link" rel="internal">
        <li>Easier async programming with async await</li>
      </a>
    </ul>
  </nav>

  <main id="main-doc">
    <section class="main-section" id="Introduction">
      <header>Introduction</header>
      <article>
        <p>Asynchronous JavaScript is used to effectively handle potential blocking operations such as fetching
          resources from a server. When only one thing happens at once, a function depending on another function has to
          wait for the other function to finish and return. From the perspective of the user, the program is essentially
          stopped during that time and a spinning cursor on the screen is generally visible.</p>
        <p>This is a frustrating experience and a waste of computing processing power.Asynchronous programming lets you
          get other work done in the meantime. This is important in the case of web browsers. When a web app runs in a
          browser and it executes and intensive chunk of code without returning control to the browser, this one can
          appear to be frozen. This is called <strong>blocking</strong>: the browser is prevented from handling user
          input.</p>
        <p>Modern software design increasingly revolves around <strong>asynchronous programming</strong> to allow
          programs to do more than one thing at a time. It used to be hard to write asynchronous code but it's gotten a
          lot easier. We'll explore further why asynchronous code matters and how to design code that avoids blocking,
          spinlocks and other processor power-wasting problems.</p>
      </article>
    </section>
    <section class="main-section" id="Prerequisites">
      <header>Prerequisites</header>
      <article>
        <p>Asynchronous JavaScript is a fairly advanced topic and you are advised to work through the first tutorials
          before attempting this:</p>
        <ul>
          <li><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps">JavaScript first steps</a>
          </li>
          <li><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks">JavaScript building
              blocks</a></li>
        </ul>
      </article>
    </section>
    <section class="main-section" id="Introducing_async_JavaScript">
      <header>Introducing async JavaScript</header>

      <h2>Synchronous JavaScript</h2>
      <p>To understand what asynchronous code is, we need to understand what synchronous code is. In this block of code,
        the lines are executed one after the other:</p>

      <pre class="prettyprint"><code>
        const btn = document.querySelector('button');
        btn.addEventListener('click', () => {
          alert('You clicked me!');

          let pElem = document.createElement('p');
          pElem.textContent = 'This is a newly-added paragraph';
          document.body.appendChild(pElem);
        });
      </code></pre>

      <p>While each operation is being processed, nothing else will happen (rendering is paused). This is because
        client-side JavaScript is single-threaded blocking language: only one thing can happen at once, on a single main
        thread. Everything else is blocked until the current operation completes.</p>

      <h2>Asynchronous JavaScript</h2>
      <p>To avoid such blocking, many Web APIs now use asynchronous code, especially for fetching resources from an
        external device (accessing a database and returning data from it, for instance). There are two main types of
        asynchronous code:</p>
      <ul>
        <li>old-style callbacks</li>
        <li>newer-style promises</li>
      </ul>

      <h3>Async callbacks</h3>
      <p>Callbacks are functions that are passed as parameters to other functions to be executed whena previous
        operation has returned. The second parameter of <code>addEventListener()</code> is an example:</p>
      <pre class="prettyprint"><code>
        btn.addEventListener('click', () => console.log('I am the callback!'));
      </code></pre>
      <p>The first paramater is the type of event to be listened for, and the second parameter is the function that is
        invoked when the event is fired.</p>
      <p>When we pass a callback function to another function, we only pass the function definition as the parameter, so
        that this callback function is not executed immediately. It is "called back" (hence the name) asynchronously,
        somewhere inside the containing function's body. The containing function is responsible for executing the
        callback function when the time comes.</p>
      <pre class="prettyprint"><code>
        function loadAsset(url, type, callback) {
          let xhr = new XMLHttpRequest();
          xhr.open('GET', url);
          xhr.responseType = type;
          xhr.onload = () => callback(xhr.response);
          xhr.send();
        }

        function displayImage(blob) {
          //displaying the resource on the user interface
        }

        loadAsset('../images/coffee.jpg', 'blob', displayImage);
      </code></pre>
      <p>Here the <code>displayImage()</code> function creates an image from the url's target and appends it to the
        document. The resource is fetched by the <code>loadAsset()</code> function and it passes the response to the
        callback to do something with it.</p>
      <p>Callbacks are versatile, they allow you to control the order in which functions are run, but also how and what
        data is passed between them. Note that some callbacks run synchronously, like when
        <code>Array.prototype.forEach()</code> loops through the items of an array.</p>
      <pre class="prettyprint"><code>
        const gods = ['Apollo', 'Artemis', 'Hermes', 'Zeus', 'Helios'];

        gods.forEach((godName, index) => {
          console.log(`${index} - ${godName}`);
        });
      </code></pre>
      <p>In this case, <code>forEach()</code> takes a unique callback as parameter and it runs immediately, without
        waiting for
        anything.</p>

      <h3>Promises</h3>
      <p>Promises are the new style of async code, used in modern web APIs. The <code>fetch()</code> API is a good
        example. It is basically a more modern and efficient version of <code>XMLHttpRequest</code>:</p>
      <pre class="prettyprint"><code>
        fetch('../source/products.json')
          .then((response) => response.json())
          .then((json) => {
            products = json;
            initialize();
          })
          .catch((error) => console.log(`Fetch problem: ${error.message}`));
      </code></pre>
      <p><code>fetch()</code> takes a single parameter, the url of the resource to fetch from the network, and returns a
        promise. The promise is an object representing the result (completion or failure) of the async operation. It
        represents an intermediate state. In essence, it's the browser's way of saying: "I promise to get back to you
        with the answer as soon as I can". Then we've got three further code blocks chained onto the end of the
        <code>fetch()</code> operation:</p>
      <ul>
        <li>Two <code>then()</code> blocks. Both contain a callback function that will run if the fetch operation is
          successful. Each callback receives the result returned by the previous successful operation. Each
          <code>then()</code> block returns a promise, meaning you can chain multiple <code>then()</code> blocks onto
          each other, so multiple async operations can be made to run in order.</li>
        <li>The <code>catch()</code> block, at the end, runs if any of the previous <code>then()</code> blocks fails. It
          is similar to <code>try {} catch {}</code>, an error object is made available inside which can be used to
          report the kind of error that has ocurred.</li>
      </ul>
      <p>Async operations like promises are put into an event queue, which runs after the main thread has finished
        processing and so <strong>does not block</strong> subsequent JavaScript code from running. The queued operations
        will complete as soon as possible then return their results to the JavaScript environment.</p>
      <h3>Conclusion</h3>
      <p>At its most basic, JavaScript is a synchronous, blocking, single-threaded language: only one action can be in
        progress at a time. But web browsers define functions and APIs that allow us to register functions that should
        not be executed synchronously but when some kind of event occurs (passage of time, user's interaction with the
        mouse, arrival of data from the network, etc.). It means that you can let your code do several things at the
        same time without blocking the main thread.</p>
    </section>

    <section class="main-section" id="Async_loops_and_intervals">
      <header>Async loops and intervals</header>
      <p>For a long time, JavaScript has made available a number of functions that allow you to asynchronously execute
        code after a certain time interval has elapsed, and repeatedly execute a block of code periodically until you
        tell it to stop. These are:</p>
      <ul>
        <li><code>setTimeout()</code> &mdash; Execute a specified block of code once after a specified time has elapsed.
        </li>
        <li><code>setInterval()</code> &mdash; Execute a specified block of code repeatedly with a fixed time delay
          between each call.</li>
        <li><code>requestAnimationFrame()</code> &mdash; The modern version of <code>setInterval()</code>, it executes a
          specified block of code before the browser next repaints the display, allowing an animation to be run at a
          suitable framerate, regardless of the environment it is being run in.</li>
      </ul>
      <p>These functions actually run on the main thread, but you're able to run other code between iterations to a more
        or less efficient degree, depending on how processor intensive these operations are. These functions are used
        for running constant animations and other background processing on a web site or application.</p>

      <h2>setTimeout()</h2>
      <p><code>setTimeout()</code> executes a specified block of code once after a specified time has elapsed. It takes
        the following parameters:</p>
      <ul>
        <li>A function to run, or a reference to a function defined elsewhere.</li>
        <li>A number representing the number of milliseconds to wait before executing that function. If you specify a
          value or 0 or omit the number, then the function will run immediately.</li>
        <li>Zero or more values that represent the parameters you want to pass to the function when it is run.</li>
      </ul>
      <p>Here, the browser will wait for 2 seconds and display an alert message:</p>
      <pre class="prettyprint"><code>
        const myGreeting = setTimeout(() => {
          alert('Hello Mr Universe!');
        }, 2000);
      </code></pre>
      <p>The function could be named and even defined somewhere else:</p>
      <pre class="prettyprint"><code>
        function sayHi() {
          alert('Hello Mr Universe!');
        }

        const myGreeting = setTimeout(sayHi, 2000);
      </code></pre>
      <p><code>setTimeout()</code> returns an identifier value that can be used to refer to the timeout later, to stop
        it for instance (see "Clearing timeouts", below).</p>
      <h3>Passing parameters to a setTimeout() function</h3>
      <p>Any parameter we want to pass to the function being run inside <code>setTimeout()</code> have to be passed as
        additional parameters, at the end of the list:</p>
      <pre class="prettyprint"><code>
        function sayHi(who) {
          alert(`Hello ${who}!`);
        }

        let myGreeting = setTimeout(sayHi, 2000, 'Mr Universe');
      </code></pre>
      <p>The name of the person to say hello is passed as a third parameter.</p>
      <h3>Clearing timeouts</h3>
      <p>Finally, if a timeout has been created, you can cancel it before the specified time has elapsed by calling
        <code>clearTimeout()</code> and passing it the identifier of the <code>setTimeout()</code> call as a parameter:
      </p>
      <pre class="prettyprint"><code>
        clearTimeout(myGreeting);
      </code></pre>

      <h2>setInterval()</h2>
      <p><code>setInterval()</code> runs a block of code over and over again. It works in a similar way to
        <code>setTimeout()</code>, except that the function passed to it as first parameter is executed repeatedly at an
        interval equal to the number of milliseconds provided as the second parameter. You can also pass any parameters
        required by the function being executed in as subsequent parameters of the <code>setInterval()</code> call.</p>
      <p>The following function creates a new <code>Date()</code> object, extracts a time string out of it, using
        <code>toLocaleTimeString()</code> and then displays it in the UI. We then run it once per second using
        <code>setInterval()</code>, creating the effect of a digital clock that updates once per second.</p>
      <pre class="prettyprint"><code>
        function displayTime() {
          let date = new Date();
          let time = date.toLocaleTimeString();
          document.getElementById('demo').textContent = time;
        }

        const createClock = setInterval(displayTime, 1000);
      </code></pre>

      <h3>Clearing intervals</h3>
      <p><code>setInterval()</code> keeps running a task forever. We may want to stop such tasks to prevent errors when
        the browser can't complete a cycle or of the animation being handled has finished. We can do it the same way as
        we stopped timeouts, by passing the identifier returned by <code>setInterval()</code> to the
        <code>clearInterval()</code> function:</p>
      <pre class="prettyprint"><code>
        const myInterval = setInterval(myFunction, 2000);

        clearInterval(myInterval);
      </code></pre>

      <h2>Things to keep in mind about setTimeout() and setInterval()</h2>
      <h3>Recursive timeouts</h3>
      <p><code>setTimeout()</code> can be called recursively to run the same code repeatedly, instead of using
        <code>setInterval()</code>. Here is an illustration:</p>
      <pre class="prettyprint"><code>
        let i = 1;
        setTimeout(function run() => {
          console.log(i);
          i++;
          setTimeout(run, 100);
        }, 100);
      </code></pre>
      <p>Here is the version using <code>setInterval()</code>:</p>
      <pre class="prettyprint"><code>
        let i = 1;
        setInterval(() => {
          console.log(i);
          i++;
        }, 100);
      </code></pre>
      <p>The difference between the two versions of the code is a subtle one</p>
      <ul>
        <li>Recursive <code>setTimeout()</code> guarantees a 100 ms delay between the executions. The code will run and
          then wait 100 milliseconds before it runs again. The interval will be the same regardless of how long the code
          takes to run.</li>
        <li><code>setInterval()</code> does things somewhat differently. The interval we choose <em>includes</em> the
          time taken to execute the code we want to run in. Let's say the code takes 40 milliseconds to run, then the
          interval ends up being only 60 milliseconds.</li>
      </ul>
      <p>When your code has the potential to take longer to run than the time interval you've assigned, it's better to
        use recursive <code>setTimeout()</code>. This will keep the time interval constant between executions regardless
        of how long the code takes to execute, and you won't get errors.</p>

      <h3>Immediate timeouts</h3>
      <p>Using 0 as the value of <code>setTimeout()</code> schedules the execution of the passed function as soon as
        possible, but only after the main thread has been run. In the following code, the alert "World" will only run
        after clicking OK on the alert "Hello":</p>
      <pre class="prettyprint"><code>
        setTimeout(() => alert('World'), 0);
        alert('Hello');
      </code></pre>
      <p>This can be useful in cases where you want to set a block of code to run as soon as all of the main thread has
        finished running. Put it on the async event loop, so it will run straight afterward.</p>

      <h3>Clearing with clearTimeout() or clearInterval()</h3>
      <p><code>clearInterval()</code> and <code>clearTimeout()</code> use the same list of entries to clear from.
        Interestingly enough, this means that you can use either method to clear a <code>setTimeout()</code> or
        <code>setInterval()</code>. But to avoid confusion and for consistency, use the appropriate method.</p>

      <h2>requestAnimationFrame()</h2>
      <p><code>requestAnimationFrame()</code> is a specialized looping function created for running animations in the
        browser. It is basically the modern version of <code>setInterval()</code>. It executes a specified block of code
        before the browser next repaints the display, allowing an animation to be run at a suitable framerate regardless
        of the environment it is being run in.</p>
      <p>The method takes a callback to be invoked before the repaint as argument. This is the general pattern you'll
        see it used:</p>
      <pre class="prettyprint"><code>
        function draw() {
          // Drawing code goes here
          requestAnimationFrame(draw);
        }

        draw();
      </code></pre>
      <p>The idea is that you define a function in which your animation is updated, then you call it to start the
        process off. At the end of the function block, you call <code>requestAnimationFrame()</code> with the function
        reference passed as the parameter and this instructs the browser to call the function again on the next display
        repaint. This is then run continuously, as we are calling <code>requestAnimationFrame()</code> recursively.</p>
      <p>We don't specify a time interval for <code>requestAnimationFrame()</code>. It just runs as fast and smoothly as
        possible in the current conditions (as close as possible to 60 fps - frames per second). The browser doesn't
        waste time running the animation if it is offscreen, etc.</p>
      <h3>Including a timestamp</h3>
      <p>The callback passed to the <code>requestAnimationFrame()</code> function also accepts a parameter: a timestamp
        value that represents the time since the animation started running. This is useful as this allows to run things
        at specific times and at a constant pace, regardless of how fast or slow the device might be.</p>
      <pre class="prettyprint"><code>
        let startTime = null;
        function draw(timestamp) {
          if (!startTime) {
            startTime = timestamp;
          }
          currenTime = timestamp - startTime;
          // Do something based on current time
          requestAnimationFrame(draw);
        }
      </code></pre>
      <h3>Clearing a <code>requestAnimationFrame()</code> call</h3>
      <p>Clearing a <code>requestAnimationFrame()</code> can be done calling the corresponding
        <code>cancelAnimationFrame()</code>, passing it the value returned by the <code>requestAnimationFrame()</code>
        (stored in a variable)</p>
      <pre class="prettyprint"><code>
        cancelAnimationFrame(myRaF);
      </code></pre>

      <section class="main-section" id="Async_operations_with_Promises">
        <header>Async operations with Promises</header>
        <p>A promise is an object that represents an intermediate state of an operation: <em>a</em> promise that a
          result of some kind will be returned at some point in the future.</p>

        <h2>The trouble with callbacks</h2>
        <p>To fully understand why promises are a good thing, it helps to think back why old-style callbacks are
          problematic.</p>
        <p>Let's talk about ordering pizza as an analogy. There are certain steps that you have to take for your order
          to be successful, which don't really make sense to try to execute out of order, or in order but before each
          previous step has quite finished:</p>
        <ol>
          <li>You choose what pizza you want. This can take a while if you're indecisive and may fail if you can't make
            up your mind, or decide to get a curry instead.</li>
          <li>You then place your order. This can take a while to return a pizza and may fail if the restaurant does not
            have the required ingredients to cook it.</li>
          <li>You then collect your pizza and eat. This may fail if, says, you forgot your wallet so can't pay for the
            pizza!</li>
        </ol>
        <p>With old-style callbacks, a pseudo-code representation of the above functionality might look something like
          this:</p>
        <pre class="prettyprint"><code>
          choosePizza((order) => {
            placeOrder(order, (pizza) => {
              collectOrder(pizza, (enjoy) => {
                eatPizza(enjoy);
              }, failureCallback);
            }, failureCallback);
          }, failureCallback);
        </code></pre>
        <p>This is messy and hard to read (often referred to as "callback hell"). If this were real code, it would
          likely block the main thread until it completes and would require you to call the
          <code>failureCallback()</code> multiple times.</p>

        <h2>Improvements with promises</h2>
        <p>Promises make situation like the above much easier to write, parse and run. If we represented the above
          peudo-code using asynchronous promises instead, we'd end up with something like this:</p>
        <pre class="prettyprint"><code>
          choosePizza()
            .then(order => placeOrder(order))
            .then(pizza => collectOrder(pizza))
            .then(enjoy => eatPizza(enjoy))
            .catch(failureCallback);
        </code></pre>
        <p>This is much better. It is easier to see what's going on and a single <code>.catch()</code> block is needed
          to handle all the errors. It doesn't block the main thread and each operation is guaranteed to wait for
          previous operations to complete before running. We're able to chain multiple asynchronous actions to occur one
          after another because each <code>.then()</code> block returns a new promise that resolves when the
          <code>.then()</code> block is done running.</p>
        <p>At their most basic promises are similar to event listeners, but with a few differences:</p>
        <ul>
          <li>A promise can only succeed or fail once. It cannot succeed or fail twice and it cannot switch from success
            to failure or vice versa once the operation has completed.</li>
          <li>If a promise has succeeded or failed and you later add a success / failure callback, the correct callback
            will be called, even though the event took place earlier</li>
        </ul>

        <h2>Explaining basic promise syntax: a real example</h2>
        <p></p>
      </section>
      <section class="main-section" id="Easier_async_programming_with_async_await">
        <header>Easier async programming with async await</header>
      </section>
  </main>

  <footer>
    <p>This page was built using the <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous"
        target="_blank" rel="noopener noreferrer">Mozilla Developer Network</a> documentation</p>
  </footer>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?skin=desert"></script>
  <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
</body>

</html>